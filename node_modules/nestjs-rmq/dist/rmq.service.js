"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RMQService = void 0;
const common_1 = require("@nestjs/common");
const constants_1 = require("./constants");
const events_1 = require("events");
const amqp = require("amqp-connection-manager");
const router_emmiter_1 = require("./emmiters/router.emmiter");
const rmq_error_class_1 = require("./classes/rmq-error.class");
const logger_1 = require("./helpers/logger");
const option_validator_1 = require("./option.validator");
const rmq_metadata_accessor_1 = require("./rmq-metadata.accessor");
const rmq_error_service_1 = require("./rmq-error.service");
const get_uniq_id_1 = require("./utils/get-uniq-id");
let RMQService = class RMQService {
    constructor(options, metadataAccessor, errorService) {
        this.metadataAccessor = metadataAccessor;
        this.errorService = errorService;
        this.server = null;
        this.clientChannel = null;
        this.subscriptionChannel = null;
        this.sendResponseEmitter = new events_1.EventEmitter();
        this.replyQueue = constants_1.REPLY_QUEUE;
        this.isConnected = false;
        this.isInitialized = false;
        this.options = options;
        this.logger = options.logger ? options.logger : new logger_1.RQMColorLogger(this.options.logMessages);
        option_validator_1.validateOptions(this.options, this.logger);
    }
    onModuleInit() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.init();
            this.isInitialized = true;
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                const connectionURLs = this.options.connections.map((connection) => {
                    return `amqp://${connection.login}:${connection.password}@${connection.host}`;
                });
                const connectionOptions = {
                    reconnectTimeInSeconds: (_a = this.options.reconnectTimeInSeconds) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_RECONNECT_TIME,
                    heartbeatIntervalInSeconds: (_b = this.options.heartbeatIntervalInSeconds) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_HEARTBEAT_TIME,
                };
                this.server = amqp.connect(connectionURLs, connectionOptions);
                this.server.on(constants_1.CONNECT_EVENT, (connection) => {
                    this.isConnected = true;
                    this.attachEmitters();
                });
                this.server.on(constants_1.DISCONNECT_EVENT, (err) => {
                    this.isConnected = false;
                    this.detachEmitters();
                    this.logger.error(constants_1.DISCONNECT_MESSAGE);
                    this.logger.error(err.err);
                });
                yield Promise.all([this.createClientChannel(), this.createSubscriptionChannel()]);
                resolve();
            }));
        });
    }
    ack(...params) {
        return this.subscriptionChannel.ack(...params);
    }
    nack(...params) {
        return this.subscriptionChannel.nack(...params);
    }
    send(topic, message, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                yield this.initializationCheck();
                const correlationId = get_uniq_id_1.getUniqId();
                const timeout = (_b = (_a = options === null || options === void 0 ? void 0 : options.timeout) !== null && _a !== void 0 ? _a : this.options.messagesTimeout) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_TIMEOUT;
                const timerId = setTimeout(() => {
                    reject(new rmq_error_class_1.RMQError(`${constants_1.ERROR_TIMEOUT}: ${timeout} while sending to ${topic}`, constants_1.ERROR_TYPE.TRANSPORT));
                }, timeout);
                this.sendResponseEmitter.once(correlationId, (msg) => {
                    clearTimeout(timerId);
                    if (msg.properties.headers['-x-error']) {
                        reject(this.errorService.errorHandler(msg));
                    }
                    const { content } = msg;
                    if (content.toString()) {
                        this.logger.debug(`Received ▼ [${topic}] ${content.toString()}`);
                        resolve(JSON.parse(content.toString()));
                    }
                    else {
                        reject(new rmq_error_class_1.RMQError(constants_1.ERROR_NONE_RPC, constants_1.ERROR_TYPE.TRANSPORT));
                    }
                });
                yield this.clientChannel.publish(this.options.exchangeName, topic, Buffer.from(JSON.stringify(message)), Object.assign({ replyTo: this.replyQueue, appId: this.options.serviceName, timestamp: new Date().getTime(), correlationId }, options));
                this.logger.debug(`Sent ▲ [${topic}] ${JSON.stringify(message)}`);
            }));
        });
    }
    notify(topic, message, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.initializationCheck();
            yield this.clientChannel.publish(this.options.exchangeName, topic, Buffer.from(JSON.stringify(message)), Object.assign({ appId: this.options.serviceName, timestamp: new Date().getTime() }, options));
            this.logger.debug(`[${topic}] ${JSON.stringify(message)}`);
        });
    }
    healthCheck() {
        return this.isConnected;
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            this.detachEmitters();
            this.sendResponseEmitter.removeAllListeners();
            yield this.clientChannel.close();
            yield this.subscriptionChannel.close();
            yield this.server.close();
        });
    }
    createSubscriptionChannel() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                this.subscriptionChannel = this.server.createChannel({
                    json: false,
                    setup: (channel) => __awaiter(this, void 0, void 0, function* () {
                        var _a, _b, _c;
                        yield channel.assertExchange(this.options.exchangeName, this.options.assertExchangeType ? this.options.assertExchangeType : 'topic', Object.assign(Object.assign({}, this.options.exchangeOptions), { durable: (_a = this.options.isExchangeDurable) !== null && _a !== void 0 ? _a : true }));
                        yield channel.prefetch((_b = this.options.prefetchCount) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_PREFETCH_COUNT, (_c = this.options.isGlobalPrefetchCount) !== null && _c !== void 0 ? _c : false);
                        if (this.options.queueName) {
                            this.listen(channel);
                        }
                        this.logConnected();
                        resolve();
                    }),
                });
            });
        });
    }
    createClientChannel() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                this.clientChannel = this.server.createChannel({
                    json: false,
                    setup: (channel) => __awaiter(this, void 0, void 0, function* () {
                        yield channel.consume(this.replyQueue, (msg) => {
                            this.sendResponseEmitter.emit(msg.properties.correlationId, msg);
                        }, {
                            noAck: true,
                        });
                        resolve();
                    }),
                });
            });
        });
    }
    listen(channel) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            yield channel.assertQueue(this.options.queueName, {
                durable: (_a = this.options.isQueueDurable) !== null && _a !== void 0 ? _a : true,
                arguments: (_b = this.options.queueArguments) !== null && _b !== void 0 ? _b : {},
            });
            yield this.bindRMQRoutes(channel);
            yield channel.consume(this.options.queueName, (msg) => __awaiter(this, void 0, void 0, function* () {
                this.logger.debug(`Received ▼ [${msg.fields.routingKey}] ${msg.content}`);
                if (this.isTopicExists(msg.fields.routingKey)) {
                    msg = yield this.useMiddleware(msg);
                    router_emmiter_1.requestEmitter.emit(msg.fields.routingKey, msg);
                }
                else {
                    this.reply('', msg, new rmq_error_class_1.RMQError(constants_1.ERROR_NO_ROUTE, constants_1.ERROR_TYPE.TRANSPORT));
                }
            }), { noAck: false });
        });
    }
    bindRMQRoutes(channel) {
        return __awaiter(this, void 0, void 0, function* () {
            this.routes = this.metadataAccessor.getAllRMQPaths();
            if (this.routes.length > 0) {
                this.routes.map((r) => __awaiter(this, void 0, void 0, function* () {
                    this.logger.log(`Mapped ${r}`, 'RMQRoute');
                    yield channel.bindQueue(this.options.queueName, this.options.exchangeName, r);
                }));
            }
        });
    }
    detachEmitters() {
        router_emmiter_1.responseEmitter.removeAllListeners();
    }
    attachEmitters() {
        router_emmiter_1.responseEmitter.on(router_emmiter_1.ResponseEmitterResult.success, (msg, result) => __awaiter(this, void 0, void 0, function* () {
            this.reply(result, msg);
        }));
        router_emmiter_1.responseEmitter.on(router_emmiter_1.ResponseEmitterResult.error, (msg, err) => __awaiter(this, void 0, void 0, function* () {
            this.reply('', msg, err);
        }));
        router_emmiter_1.responseEmitter.on(router_emmiter_1.ResponseEmitterResult.ack, (msg) => __awaiter(this, void 0, void 0, function* () {
            this.ack(msg);
        }));
    }
    reply(res, msg, error = null) {
        return __awaiter(this, void 0, void 0, function* () {
            res = yield this.intercept(res, msg, error);
            yield this.subscriptionChannel.sendToQueue(msg.properties.replyTo, Buffer.from(JSON.stringify(res)), {
                correlationId: msg.properties.correlationId,
                headers: Object.assign({}, this.errorService.buildError(error)),
            });
            this.logger.debug(`Sent ▲ [${msg.fields.routingKey}] ${JSON.stringify(res)}`);
        });
    }
    isTopicExists(topic) {
        return !!this.routes.find((x) => x === topic);
    }
    useMiddleware(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.options.middleware || this.options.middleware.length === 0) {
                return msg;
            }
            for (const middleware of this.options.middleware) {
                msg = yield new middleware(this.logger).transform(msg);
            }
            return msg;
        });
    }
    intercept(res, msg, error) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.options.intercepters || this.options.intercepters.length === 0) {
                return res;
            }
            for (const intercepter of this.options.intercepters) {
                res = yield new intercepter(this.logger).intercept(res, msg, error);
            }
            return res;
        });
    }
    initializationCheck() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isInitialized) {
                return;
            }
            yield new Promise(resolve => {
                setTimeout(() => {
                    resolve();
                }, constants_1.INITIALIZATION_STEP_DELAY);
            });
            yield this.initializationCheck();
        });
    }
    logConnected() {
        this.logger.log(constants_1.CONNECTED_MESSAGE, 'RMQModule');
        if (!this.options.queueName && this.metadataAccessor.getAllRMQPaths().length > 0) {
            this.logger.warn(constants_1.ERROR_NO_QUEUE, 'RMQModule');
        }
    }
};
RMQService = __decorate([
    common_1.Injectable(),
    __param(0, common_1.Inject(constants_1.RMQ_MODULE_OPTIONS)),
    __metadata("design:paramtypes", [Object, rmq_metadata_accessor_1.RMQMetadataAccessor,
        rmq_error_service_1.RmqErrorService])
], RMQService);
exports.RMQService = RMQService;
